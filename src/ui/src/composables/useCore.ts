/**
 * Vue composable for integrating with Crux Core
 *
 * This composable provides the bridge between the Vue UI shell and the
 * Crux Core (Rust compiled to WASM). It handles:
 * - Sending events to the core
 * - Processing effects from the core
 * - Providing reactive access to the view model
 *
 * The generated types from shared_types provide serialization/deserialization
 * for bincode FFI communication with the WASM module.
 *
 * Build the WASM module with:
 *   cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
 *
 * Generate TypeScript types with:
 *   export PATH="$HOME/.local/share/pnpm:$PATH" && cargo build -p shared_types
 */

import { ref, reactive, readonly, type DeepReadonly } from 'vue'
import { useCentrifuge } from './useCentrifugo'
import { CentrifugeSubscriptionType } from '../enums/centrifuge-subscription-type.enum'

// Re-export generated types from shared_types for use in Vue components
// These types are generated by TypeGen from the Crux Core Rust types
export type {
	SystemInfo,
	NetworkStatus,
	OnlineStatus,
	FactoryReset,
	UpdateValidationStatus,
	Timeouts,
	HealthcheckInfo,
	Event,
	Effect,
	Model as CoreViewModel,
	UpdateManifest,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import event constructors for sending events to the core
import type {
	OdsOnlineStatus,
	OdsSystemInfo,
	OdsTimeouts,
	OdsNetworkStatus,
	OdsFactoryReset,
	OdsUpdateValidationStatus,
} from '../types/ods'
import {
	EventVariantInitialize,
	EventVariantLogin,
	EventVariantLogout,
	EventVariantSetPassword,
	EventVariantUpdatePassword,
	EventVariantCheckRequiresPasswordSet,
	EventVariantReboot,
	EventVariantFactoryResetRequest,
	EventVariantReloadNetwork,
	EventVariantSetNetworkConfig,
	EventVariantLoadUpdate,
	EventVariantRunUpdate,
	EventVariantSubscribeToChannels,
	EventVariantUnsubscribeFromChannels,
	EventVariantClearError,
	EventVariantClearSuccess,
	// Update events for Centrifugo data
	EventVariantSystemInfoUpdated,
	EventVariantNetworkStatusUpdated,
	EventVariantOnlineStatusUpdated,
	EventVariantFactoryResetUpdated,
	EventVariantUpdateValidationStatusUpdated,
	EventVariantTimeoutsUpdated,
	type Event,
	SystemInfo,
	OsInfo,
	NetworkStatus,
	DeviceNetwork,
	InternetProtocol,
	IpAddress,
	OnlineStatus,
	FactoryReset,
	FactoryResetResult,
	FactoryResetStatus,
	UpdateValidationStatus,
	Timeouts,
	Duration,
	Model as GeneratedViewModel,
	Request as CruxRequest,
	EffectVariantRender,
	EffectVariantHttp,
	EffectVariantCentrifugo,
	FactoryResetStatusVariantunknown,
	FactoryResetStatusVariantmode_supported,
	FactoryResetStatusVariantmode_unsupported,
	FactoryResetStatusVariantbackup_restore_error,
	FactoryResetStatusVariantconfiguration_error,
	HttpResponse as CoreHttpResponse,
	HttpHeader as CoreHttpHeader,
	HttpResultVariantOk,
	HttpResultVariantErr,
	HttpErrorVariantIo,
	// Centrifugo types (only SubscribeAll is used)
	CentrifugoOperationVariantSubscribeAll,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import serialization utilities
import { BincodeSerializer } from '../../../shared_types/generated/typescript/bincode/mod'
import { BincodeDeserializer } from '../../../shared_types/generated/typescript/bincode/mod'

// Helper to convert FactoryResetStatus class variant to string literal
type FactoryResetStatusString = 'unknown' | 'mode_supported' | 'mode_unsupported' | 'backup_restore_error' | 'configuration_error'

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function factoryResetStatusToString(status: any): FactoryResetStatusString {
  if (status instanceof FactoryResetStatusVariantunknown) return 'unknown'
  if (status instanceof FactoryResetStatusVariantmode_supported) return 'mode_supported'
  if (status instanceof FactoryResetStatusVariantmode_unsupported) return 'mode_unsupported'
  if (status instanceof FactoryResetStatusVariantbackup_restore_error) return 'backup_restore_error'
  if (status instanceof FactoryResetStatusVariantconfiguration_error) return 'configuration_error'
  return 'unknown'
}

// Simple ViewModel interface for Vue reactivity (mirrors CoreViewModel but with JS types)
export interface ViewModel {
	system_info: {
    os: { name: string; version: string }
    azure_sdk_version: string
    omnect_device_service_version: string
    boot_time: string | null
  } | null
	network_status: {
		network_status: Array<{
			ipv4: {
        addrs: Array<{ addr: string; dhcp: boolean; prefix_len: number }>
        dns: string[]
        gateways: string[]
      }
      mac: string
      name: string
      online: boolean
    }>
  } | null
  online_status: { iothub: boolean } | null
	factory_reset: {
    keys: string[]
		result: {
      status: 'unknown' | 'mode_supported' | 'mode_unsupported' | 'backup_restore_error' | 'configuration_error'
      context: string | null
      error: string
      paths: string[]
    } | null
  } | null
  update_validation_status: { status: string } | null
  update_manifest: UpdateManifest | null
  timeouts: { wait_online_timeout: { nanos: number; secs: bigint } } | null
	healthcheck: {
    version_info: { version: string; git_sha: string }
    update_validation_status: { status: string }
  } | null
  is_authenticated: boolean
  requires_password_set: boolean
  is_loading: boolean
  error_message: string | null
  success_message: string | null
  is_connected: boolean
  auth_token: string | null
}

// Singleton state
const viewModel = reactive<ViewModel>({
	system_info: null,
	network_status: null,
	online_status: null,
	factory_reset: null,
	update_validation_status: null,
	update_manifest: null,
	timeouts: null,
	healthcheck: null,
	is_authenticated: false,
	requires_password_set: false,
	is_loading: false,
	error_message: null,
	success_message: null,
	is_connected: false,
	auth_token: null,
})

const isInitialized = ref(false)
const isSubscribed = ref(false)
const authToken = ref<string | null>(null) // New ref for auth token

// Centrifugo instance for WebSocket operations
const centrifugoInstance = useCentrifuge()
// Inject the auth token ref into Centrifugo to avoid circular dependency
centrifugoInstance.setAuthToken(authToken)

// WASM module reference (will be set when WASM is loaded)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let wasmModule: any = null

// Promise-based initialization guard to prevent both race conditions and premature event sending
let initializationPromise: Promise<void> | null = null

// ============================================================================
// Event Serialization
// ============================================================================

/**
 * Serialize an Event to bincode bytes for sending to WASM Core
 */
function serializeEvent(event: Event): Uint8Array {
	const serializer = new BincodeSerializer()
	event.serialize(serializer)
	return serializer.getBytes()
}

// ============================================================================
// HTTP Capability Implementation
// ============================================================================

/**
 * Execute an HTTP request and return the result to the Core
 *
 * This is the shell's implementation of the HTTP capability.
 * It converts the Core's HttpRequest into a fetch() call,
 * then serializes the result back for the Core to process.
 */
async function executeHttpRequest(
	requestId: number,
  httpRequest: { method: string; url: string; headers: Array<{ name: string; value: string }>; body: Uint8Array }
): Promise<void> {
	if (!wasmModule) {
    console.warn('WASM module not loaded, cannot execute HTTP request')
		return
	}

	try {
    const headers = new Headers()
		for (const header of httpRequest.headers) {
      headers.append(header.name, header.value)
		}

		const fetchOptions: RequestInit = {
			method: httpRequest.method,
			headers,
			credentials: "include",
		}

    if (httpRequest.method !== 'GET' && httpRequest.method !== 'HEAD' && httpRequest.body.length > 0) {
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			fetchOptions.body = httpRequest.body as any
		}

		// Workaround: `crux_http` in the Rust core panics on relative URLs.
		// The Rust side prefixes URLs with `http://omnect-device` to satisfy `crux_http`'s validation.
		// This side strips the prefix to send a relative URL, which `fetch` handles correctly.
		// TODO: Remove this workaround once `crux_http` supports relative URLs gracefully.
    let url = httpRequest.url
    if (url.startsWith('http://omnect-device')) {
      url = url.replace('http://omnect-device', '')
		}

    const response = await fetch(url, fetchOptions)

		// Convert response headers
    const responseHeaders: Array<CoreHttpHeader> = []
		response.headers.forEach((value, name) => {
      responseHeaders.push(new CoreHttpHeader(name, value))
    })

		// Get response body as bytes
    const bodyBuffer = await response.arrayBuffer()
    const bodyBytes = new Uint8Array(bodyBuffer)
    console.log(`[HTTP Effect ${requestId}] Response body: ${bodyBytes.length} bytes`)

		// Create HttpResponse
    const httpResponse = new CoreHttpResponse(response.status, responseHeaders, bodyBytes)

		// Create success result
    const result = new HttpResultVariantOk(httpResponse)

    const serializer = new BincodeSerializer()
    result.serialize(serializer)
    const resultBytes = serializer.getBytes()
    const newEffectsBytes = wasmModule.handle_response(requestId, resultBytes) as Uint8Array
		if (newEffectsBytes.length > 0) {
      await processEffects(newEffectsBytes)
		}
	} catch (error) {
		// Create error result
    const errorMessage = error instanceof Error ? error.message : String(error)
    console.error(`[HTTP Effect ${requestId}] Error:`, errorMessage)
    const httpError = new HttpErrorVariantIo(errorMessage)
    const result = new HttpResultVariantErr(httpError)

    const serializer = new BincodeSerializer()
    result.serialize(serializer)
    const resultBytes = serializer.getBytes()
    const newEffectsBytes = wasmModule.handle_response(requestId, resultBytes) as Uint8Array
		if (newEffectsBytes.length > 0) {
      await processEffects(newEffectsBytes)
		}
	}
}

// ============================================================================
// Centrifugo Capability Implementation
// ============================================================================

/**
 * Convert ODS FactoryResetStatus string to typed variant
 */
function stringToFactoryResetStatus(status: string): FactoryResetStatus {
	switch (status) {
    case 'mode_supported':
      return new FactoryResetStatusVariantmode_supported()
    case 'mode_unsupported':
      return new FactoryResetStatusVariantmode_unsupported()
    case 'backup_restore_error':
      return new FactoryResetStatusVariantbackup_restore_error()
    case 'configuration_error':
      return new FactoryResetStatusVariantconfiguration_error()
		default:
      return new FactoryResetStatusVariantunknown()
	}
}

/**
 * Parse WebSocket channel data from ODS JSON and send as typed event to Core
 *
 * Architecture:
 * - Receives JSON from Centrifugo WebSocket (ODS data format)
 * - Parses JSON and constructs typed TypeScript class instances
 * - Sends as *Updated events to Core (not responses)
 * - Core processes events, updates Model, and renders
 * - Shell reads updated viewModel from Core
 *
 * This event-based approach avoids request/response conflicts with streaming data.
 */
async function parseAndSendChannelEvent(channel: string, jsonData: string): Promise<void> {
	try {
		switch (channel) {
      case 'OnlineStatusV1': {
        const json = JSON.parse(jsonData) as OdsOnlineStatus
        const data = new OnlineStatus(json.iothub)
        await sendEventToCore(new EventVariantOnlineStatusUpdated(data))
        break
			}
      case 'SystemInfoV1': {
        const json = JSON.parse(jsonData) as OdsSystemInfo
				const data = new SystemInfo(
          new OsInfo(json.os?.name || '', json.os?.version || ''),
          json.azure_sdk_version || '',
          json.omnect_device_service_version || '',
          json.boot_time ? String(json.boot_time) : null
        )
        await sendEventToCore(new EventVariantSystemInfoUpdated(data))
        break
			}
      case 'TimeoutsV1': {
        const json = JSON.parse(jsonData) as OdsTimeouts
				const data = new Timeouts(
					new Duration(
						json.wait_online_timeout?.nanos || 0,
            BigInt(json.wait_online_timeout?.secs || 0)
          )
        )
        await sendEventToCore(new EventVariantTimeoutsUpdated(data))
        break
			}
      case 'NetworkStatusV1': {
        const json = JSON.parse(jsonData) as OdsNetworkStatus
        console.log('NetworkStatusV1 WebSocket update received:', json)
				const networks = (json.network_status || []).map((net) => {
          console.log('Network adapter:', net.name, 'dhcp:', net.ipv4?.addrs[0]?.dhcp)
					return new DeviceNetwork(
						new InternetProtocol(
              (net.ipv4?.addrs || []).map((addr) =>
                new IpAddress(addr.addr || '', addr.dhcp || false, addr.prefix_len || 0)
							),
							net.ipv4?.dns || [],
              net.ipv4?.gateways || []
						),
            net.mac || '',
            net.name || '',
						net.online || false,
            net.file || null
          )
        })
        const data = new NetworkStatus(networks)
        await sendEventToCore(new EventVariantNetworkStatusUpdated(data))
        break
			}
      case 'FactoryResetV1': {
        const json = JSON.parse(jsonData) as OdsFactoryReset
				// Only send if we have complete data
				if (!json.result) {
          break
				}

				const result = new FactoryResetResult(
          stringToFactoryResetStatus(json.result.status || 'unknown'),
					json.result.context || null,
          json.result.error || '',
          json.result.paths || []
        )
        const data = new FactoryReset(json.keys || [], result)
        await sendEventToCore(new EventVariantFactoryResetUpdated(data))
        break
			}
      case 'UpdateValidationStatusV1': {
        const json = JSON.parse(jsonData) as OdsUpdateValidationStatus
        const data = new UpdateValidationStatus(json.status || '')
        await sendEventToCore(new EventVariantUpdateValidationStatusUpdated(data))
        break
			}
			default:
        console.warn(`[Centrifugo] Unknown channel: ${channel}`)
		}
	} catch (error) {
    console.error(`[Centrifugo] Error parsing ${channel}:`, error)
	}
}

/**
 * Execute Centrifugo SubscribeAll operation
 *
 * Subscribes to all Centrifugo channels and forwards messages as events to Core.
 * Uses the event-based architecture where WebSocket data is parsed and sent as
 * typed events (*Updated) rather than responses.
 *
 * Note: Only SubscribeAll is implemented - individual channel operations removed.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function executeCentrifugoOperation(operation: any): Promise<void> {
	if (operation instanceof CentrifugoOperationVariantSubscribeAll) {
    const channels = Object.values(CentrifugeSubscriptionType)
    centrifugoInstance.initializeCentrifuge()

    let subscriptionsStarted = false
		const performSubscriptions = async () => {
      if (subscriptionsStarted) return
      subscriptionsStarted = true

			for (const channel of channels) {
				await centrifugoInstance.subscribe((data: unknown) => {
          const jsonData = JSON.stringify(data)
          parseAndSendChannelEvent(channel, jsonData)
        }, channel)

				await centrifugoInstance.history((data: unknown) => {
					try {
						if (data) {
              const jsonData = JSON.stringify(data)
              parseAndSendChannelEvent(channel, jsonData)
						}
					} catch (error) {
            console.error(`[Centrifugo] Error processing history for ${channel}:`, error)
					}
        }, channel)
			}
    }

		centrifugoInstance.onConnected(() => {
      performSubscriptions()
    })
    performSubscriptions()
	} else {
    console.error(`[Centrifugo] Unsupported operation - only SubscribeAll is implemented`)
	}
}

// ============================================================================
// Effect Processing
// ============================================================================

/**
 * Process effects from the Crux Core
 *
 * Effects are the Core's way of requesting the Shell to perform side effects:
 * - Render: Fetch and update the viewModel from Core
 * - Http: Execute HTTP requests and send responses back to Core
 * - Centrifugo: Subscribe to WebSocket channels (only SubscribeAll)
 */
async function processEffects(effectsBytes: Uint8Array): Promise<void> {
	if (!wasmModule) {
    console.warn('WASM module not loaded, cannot process effects')
    return
	}

	// Deserialize effects from bincode (array of Request objects)
  const deserializer = new BincodeDeserializer(effectsBytes)
  const numRequests = deserializer.deserializeLen()

	for (let i = 0; i < numRequests; i++) {
    const request = CruxRequest.deserialize(deserializer)
    const effect = request.effect

		if (effect instanceof EffectVariantRender) {
			// Render effect: Update the view model from core
      updateViewModelFromCore()
		} else if (effect instanceof EffectVariantHttp) {
			// HTTP effect: Execute HTTP request and send response back to core
      const httpRequest = effect.value
      console.log(`HTTP ${httpRequest.method} ${httpRequest.url}`)

			// Execute the request asynchronously (don't await to allow parallel processing)
			executeHttpRequest(request.id, {
				method: httpRequest.method,
				url: httpRequest.url,
        headers: httpRequest.headers.map(h => ({ name: h.name, value: h.value })),
				body: httpRequest.body,
			}).catch((error) => {
        console.error('Failed to execute HTTP request:', error)
      })
		} else if (effect instanceof EffectVariantCentrifugo) {
			// Centrifugo effect: Handle WebSocket subscription
      const centrifugoOperation = effect.value
      console.log(`Centrifugo operation:`, centrifugoOperation)

			// Execute the operation asynchronously
			executeCentrifugoOperation(centrifugoOperation).catch((error) => {
        console.error('Failed to execute Centrifugo operation:', error)
      })
		} else {
      console.warn('Unknown effect type:', effect)
		}
	}
}

// ============================================================================
// ViewModel Synchronization
// ============================================================================

/**
 * Fetch and deserialize the view model from Crux Core
 *
 * Reads the serialized viewModel bytes from WASM, deserializes using bincode,
 * and updates the reactive Vue viewModel object.
 */
function updateViewModelFromCore(): void {
	if (!wasmModule) {
		return
	}

	try {
		// Capture authentication state before update to detect transitions
		const wasAuthenticated = viewModel.is_authenticated

		// Get serialized view model from WASM
    const viewModelBytes = wasmModule.view() as Uint8Array

		// Deserialize it using the generated ViewModel class
    const deserializer = new BincodeDeserializer(viewModelBytes)
    const coreViewModel = GeneratedViewModel.deserialize(deserializer)

		// Update the reactive view model with deserialized data
		// system_info
		if (coreViewModel.system_info) {
			viewModel.system_info = {
				os: {
					name: coreViewModel.system_info.os.name,
					version: coreViewModel.system_info.os.version,
				},
				azure_sdk_version: coreViewModel.system_info.azure_sdk_version,
        omnect_device_service_version: coreViewModel.system_info.omnect_device_service_version,
				boot_time: coreViewModel.system_info.boot_time || null,
      }
		} else {
      viewModel.system_info = null
		}

		// network_status
		if (coreViewModel.network_status) {
			viewModel.network_status = {
        network_status: coreViewModel.network_status.network_status.map((net) => ({
						ipv4: {
							addrs: net.ipv4.addrs.map((addr) => ({
								addr: addr.addr,
								dhcp: addr.dhcp,
								prefix_len: addr.prefix_len,
							})),
							dns: net.ipv4.dns,
							gateways: net.ipv4.gateways,
						},
						mac: net.mac,
						name: net.name,
						online: net.online,
        })),
      }
		} else {
      viewModel.network_status = null
		}

		// online_status
		viewModel.online_status = coreViewModel.online_status
			? { iothub: coreViewModel.online_status.iothub }
      : null

		// factory_reset - convert status variant to string literal
		// Note: Skip if deserialization fails (can happen with bincode format mismatches)
		try {
			viewModel.factory_reset = coreViewModel.factory_reset
				? {
						keys: coreViewModel.factory_reset.keys,
            result: coreViewModel.factory_reset.result ? {
              status: factoryResetStatusToString(coreViewModel.factory_reset.result.status),
									context: coreViewModel.factory_reset.result.context || null,
									error: coreViewModel.factory_reset.result.error,
									paths: coreViewModel.factory_reset.result.paths,
            } : null,
					}
        : null
		} catch (error) {
      console.warn('[updateViewModelFromCore] Failed to deserialize factory_reset, keeping existing value:', error)
		}

		// update_validation_status
		viewModel.update_validation_status = coreViewModel.update_validation_status
			? { status: coreViewModel.update_validation_status.status }
      : null

		// update_manifest
		viewModel.update_manifest = coreViewModel.update_manifest ?? null

		// timeouts
		viewModel.timeouts = coreViewModel.timeouts
			? {
					wait_online_timeout: {
						nanos: coreViewModel.timeouts.wait_online_timeout.nanos,
						secs: coreViewModel.timeouts.wait_online_timeout.secs,
					},
				}
      : null

		// healthcheck
		viewModel.healthcheck = coreViewModel.healthcheck
			? {
					version_info: {
						version: coreViewModel.healthcheck.version_info.version,
						git_sha: coreViewModel.healthcheck.version_info.git_sha,
					},
					update_validation_status: {
						status: coreViewModel.healthcheck.update_validation_status.status,
					},
				}
      : null

		// Boolean and string fields
		viewModel.is_authenticated = coreViewModel.is_authenticated
		viewModel.requires_password_set = coreViewModel.requires_password_set
		viewModel.is_loading = coreViewModel.is_loading
		viewModel.error_message = coreViewModel.error_message || null
		viewModel.success_message = coreViewModel.success_message || null
		viewModel.is_connected = coreViewModel.is_connected
		viewModel.auth_token = coreViewModel.auth_token || null
		
		// Sync the ref with the view model
		authToken.value = viewModel.auth_token

		// Auto-subscribe logic based on authentication state transition
		if (viewModel.is_authenticated && !wasAuthenticated) {
			console.log('[useCore] User authenticated, triggering subscription')
			if (authToken.value && !isSubscribed.value) {
				isSubscribed.value = true
				sendEventToCore(new EventVariantSubscribeToChannels())
			}
		}

		// Reset subscription state on logout
		if (!viewModel.is_authenticated && wasAuthenticated) {
			console.log('[useCore] User logged out, resetting subscription state')
			isSubscribed.value = false
		}
	} catch (error) {
    console.error('Failed to update view model from core:', error)
		// Don't throw - keep the viewModel as-is from events
		// This allows the app to continue working even if Core's viewModel has deserialization issues
	}
}

/**
 * Send an event to the Crux Core
 *
 * This serializes the event, sends it to the WASM core, and processes
 * any resulting effects.
 */
async function sendEventToCore(event: Event): Promise<void> {
	if (!isInitialized.value || !wasmModule) {
    console.warn('Core not initialized, cannot send event')
    return
	}

	try {
		// Serialize the event using bincode
    const eventBytes = serializeEvent(event)

		// Call process_event() on the WASM module
    const effectsBytes = wasmModule.process_event(eventBytes) as Uint8Array

		// Process the resulting effects
    await processEffects(effectsBytes)
	} catch (error) {
    console.error('Failed to send event to core:', error)
	}
}

/**
 * Initialize the Crux Core
 *
 * This loads the WASM module and sets up the core state.
 * Uses a promise-based guard to prevent both race conditions and premature event sending.
 */
async function initializeCore(): Promise<void> {
	// If initialization is already in progress or complete, wait for/return that promise
	if (initializationPromise) {
    return initializationPromise
	}

	// Create and store the initialization promise
	initializationPromise = (async () => {
    console.log('Initializing Crux Core...')

		try {
			// Dynamically import the WASM module
			// This will be available after running:
			// cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
      const wasm = await import('../core/pkg/omnect_ui_core')
      await wasm.default()
      wasmModule = wasm

      console.log('Crux Core WASM module loaded successfully')

			// Only set initialized flag after WASM is fully loaded
      isInitialized.value = true

			// Send initial event
      await sendEventToCore(new EventVariantInitialize())
		} catch (error) {
      console.error('Failed to load Crux Core WASM module:', error)
      console.log('Running in fallback mode without WASM')
			// Set initialized flag even on error to prevent retry loops
      isInitialized.value = true
		}
  })()

  return initializationPromise
}

// ============================================================================
// Public API
// ============================================================================

/**
 * Vue composable for Crux Core integration
 *
 * Provides the main interface for Vue components to interact with the Rust
 * Crux Core compiled to WASM.
 *
 * @example
 * ```typescript
 * const { viewModel, sendEvent, initialize } = useCore()
 *
 * onMounted(async () => {
 *   await initialize()
 * })
 *
 * // Access reactive view model
 * const isOnline = computed(() => viewModel.online_status?.iothub ?? false)
 *
 * // Send events using convenience methods
 * login('password')
 * reboot()
 * ```
 */
export function useCore() {
	return {
		// Provide readonly access to the view model
		viewModel: readonly(viewModel) as DeepReadonly<ViewModel>,

		// Event sending (using Event type from shared_types)
		sendEvent: sendEventToCore,
		// Provide authToken for direct use
		authToken: readonly(authToken),

		// Initialization
		initialize: initializeCore,
		isInitialized: readonly(isInitialized),

		// Convenience methods for common events
		login: (password: string) =>
			sendEventToCore(new EventVariantLogin(password)),
		logout: () => sendEventToCore(new EventVariantLogout()),
    setPassword: (password: string) => sendEventToCore(new EventVariantSetPassword(password)),
		updatePassword: (currentPassword: string, password: string) =>
      sendEventToCore(new EventVariantUpdatePassword(currentPassword, password)),
    checkRequiresPasswordSet: () => sendEventToCore(new EventVariantCheckRequiresPasswordSet()),
		reboot: () => sendEventToCore(new EventVariantReboot()),
		factoryReset: (mode: string, preserve: string[]) =>
			sendEventToCore(new EventVariantFactoryResetRequest(mode, preserve)),
		reloadNetwork: () => sendEventToCore(new EventVariantReloadNetwork()),
		setNetworkConfig: (config: string) =>
			sendEventToCore(new EventVariantSetNetworkConfig(config)),
    loadUpdate: (filePath: string) => sendEventToCore(new EventVariantLoadUpdate(filePath)),
		runUpdate: (validateIothub: boolean) =>
			sendEventToCore(new EventVariantRunUpdate(validateIothub)),
		subscribeToChannels: () => {
			if (isSubscribed.value) {
        return
			}
			if (!authToken.value) {
				console.warn('[useCore] Skipping subscription: no auth token')
				return
			}
      isSubscribed.value = true
      sendEventToCore(new EventVariantSubscribeToChannels())
		},
		unsubscribeFromChannels: () => {
      isSubscribed.value = false
      sendEventToCore(new EventVariantUnsubscribeFromChannels())
		},
		clearError: () => sendEventToCore(new EventVariantClearError()),
		clearSuccess: () => sendEventToCore(new EventVariantClearSuccess()),
  }
}
