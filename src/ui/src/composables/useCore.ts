/**
 * Vue composable for integrating with Crux Core
 *
 * This composable provides the bridge between the Vue UI shell and the
 * Crux Core (Rust compiled to WASM). It handles:
 * - Sending events to the core
 * - Processing effects from the core
 * - Providing reactive access to the view model
 *
 * The generated types from shared_types provide serialization/deserialization
 * for bincode FFI communication with the WASM module.
 *
 * Build the WASM module with:
 *   cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
 *
 * Generate TypeScript types with:
 *   export PATH="$HOME/.local/share/pnpm:$PATH" && cargo build -p shared_types
 */

import { ref, reactive, readonly, watch, type DeepReadonly } from 'vue'
import { useCentrifuge } from './useCentrifugo'
import { CentrifugeSubscriptionType } from '../enums/centrifuge-subscription-type.enum'

// Re-export generated types from shared_types for use in Vue components
// These types are generated by TypeGen from the Crux Core Rust types
export type {
	SystemInfo,
	NetworkStatus,
	OnlineStatus,
	FactoryReset,
	UpdateValidationStatus,
	Timeouts,
	HealthcheckInfo,
	Event,
	Effect,
	Model as CoreViewModel,
	UpdateManifest,
	NetworkFormData,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import event constructors for sending events to the core
import type {
	OdsOnlineStatus,
	OdsSystemInfo,
	OdsTimeouts,
	OdsNetworkStatus,
	OdsFactoryReset,
	OdsUpdateValidationStatus,
} from '../types/ods'
import {
	// Main Event wrapper variants (snake_case from serde rename_all)
	EventVariantinitialize,
	EventVariantauth,
	EventVariantdevice,
	EventVariantweb_socket,
	EventVariantui,
	// Auth event variants
	AuthEventVariantLogin,
	AuthEventVariantLogout,
	AuthEventVariantSetPassword,
	AuthEventVariantUpdatePassword,
	AuthEventVariantCheckRequiresPasswordSet,
	// Device event variants
	DeviceEventVariantReboot,
	DeviceEventVariantFactoryResetRequest,
	DeviceEventVariantReloadNetwork,
	DeviceEventVariantSetNetworkConfig,
	DeviceEventVariantLoadUpdate,
	DeviceEventVariantRunUpdate,
	DeviceEventVariantReconnectionCheckTick,
	DeviceEventVariantReconnectionTimeout,
	DeviceEventVariantNewIpCheckTick,
	DeviceEventVariantNewIpCheckTimeout,
	DeviceEventVariantNetworkFormStartEdit,
	DeviceEventVariantNetworkFormUpdate,
	DeviceEventVariantNetworkFormReset,
	// WebSocket event variants
	WebSocketEventVariantSubscribeToChannels,
	WebSocketEventVariantUnsubscribeFromChannels,
	WebSocketEventVariantSystemInfoUpdated,
	WebSocketEventVariantNetworkStatusUpdated,
	WebSocketEventVariantOnlineStatusUpdated,
	WebSocketEventVariantFactoryResetUpdated,
	WebSocketEventVariantUpdateValidationStatusUpdated,
	WebSocketEventVariantTimeoutsUpdated,
	// UI event variants
	UiEventVariantClearError,
	UiEventVariantClearSuccess,
	type Event,
	SystemInfo,
	OsInfo,
	NetworkStatus,
	DeviceNetwork,
	InternetProtocol,
	IpAddress,
	OnlineStatus,
	FactoryReset,
	FactoryResetResult,
	FactoryResetStatus,
	UpdateValidationStatus,
	Timeouts,
	Duration,
	Model as GeneratedViewModel,
	Request as CruxRequest,
	EffectVariantRender,
	EffectVariantHttp,
	EffectVariantCentrifugo,
	FactoryResetStatusVariantunknown,
	FactoryResetStatusVariantmode_supported,
	FactoryResetStatusVariantmode_unsupported,
	FactoryResetStatusVariantbackup_restore_error,
	FactoryResetStatusVariantconfiguration_error,
	HttpResponse as CoreHttpResponse,
	HttpHeader as CoreHttpHeader,
	HttpResultVariantOk,
	HttpResultVariantErr,
	HttpErrorVariantIo,
	// Centrifugo types (only SubscribeAll is used)
	CentrifugoOperationVariantSubscribeAll,
	// State types for device operations, network changes, and form state
	DeviceOperationState,
	DeviceOperationStateVariantidle,
	DeviceOperationStateVariantrebooting,
	DeviceOperationStateVariantfactory_resetting,
	DeviceOperationStateVariantupdating,
	DeviceOperationStateVariantwaiting_reconnection,
	DeviceOperationStateVariantreconnection_failed,
	DeviceOperationStateVariantreconnection_successful,
	NetworkChangeState,
	NetworkChangeStateVariantidle,
	NetworkChangeStateVariantapplying_config,
	NetworkChangeStateVariantwaiting_for_new_ip,
	NetworkChangeStateVariantnew_ip_reachable,
	NetworkChangeStateVariantnew_ip_timeout,
	NetworkFormState,
	NetworkFormStateVariantidle,
	NetworkFormStateVariantediting,
	NetworkFormStateVariantsubmitting,
	OverlaySpinnerState as CoreOverlaySpinnerState,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import serialization utilities
import { BincodeSerializer } from '../../../shared_types/generated/typescript/bincode/mod'
import { BincodeDeserializer } from '../../../shared_types/generated/typescript/bincode/mod'

// Helper to convert FactoryResetStatus class variant to string literal
type FactoryResetStatusString = 'unknown' | 'mode_supported' | 'mode_unsupported' | 'backup_restore_error' | 'configuration_error'

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function factoryResetStatusToString(status: any): FactoryResetStatusString {
  if (status instanceof FactoryResetStatusVariantunknown) return 'unknown'
  if (status instanceof FactoryResetStatusVariantmode_supported) return 'mode_supported'
  if (status instanceof FactoryResetStatusVariantmode_unsupported) return 'mode_unsupported'
  if (status instanceof FactoryResetStatusVariantbackup_restore_error) return 'backup_restore_error'
  if (status instanceof FactoryResetStatusVariantconfiguration_error) return 'configuration_error'
  return 'unknown'
}

// Helper to convert DeviceOperationState variant to typed object
function convertDeviceOperationState(state: DeviceOperationState): DeviceOperationStateType {
	if (state instanceof DeviceOperationStateVariantidle) {
		return { type: 'idle' }
	}
	if (state instanceof DeviceOperationStateVariantrebooting) {
		return { type: 'rebooting' }
	}
	if (state instanceof DeviceOperationStateVariantfactory_resetting) {
		return { type: 'factory_resetting' }
	}
	if (state instanceof DeviceOperationStateVariantupdating) {
		return { type: 'updating' }
	}
	if (state instanceof DeviceOperationStateVariantwaiting_reconnection) {
		return { type: 'waiting_reconnection', operation: state.operation, attempt: state.attempt }
	}
	if (state instanceof DeviceOperationStateVariantreconnection_failed) {
		return { type: 'reconnection_failed', operation: state.operation, reason: state.reason }
	}
	if (state instanceof DeviceOperationStateVariantreconnection_successful) {
		return { type: 'reconnection_successful', operation: state.operation }
	}
	return { type: 'idle' }
}

// Helper to convert NetworkChangeState variant to typed object
function convertNetworkChangeState(state: NetworkChangeState): NetworkChangeStateType {
	if (state instanceof NetworkChangeStateVariantidle) {
		return { type: 'idle' }
	}
	if (state instanceof NetworkChangeStateVariantapplying_config) {
		return {
			type: 'applying_config',
			is_server_addr: state.is_server_addr,
			ip_changed: state.ip_changed,
			new_ip: state.new_ip,
			old_ip: state.old_ip,
		}
	}
	if (state instanceof NetworkChangeStateVariantwaiting_for_new_ip) {
		return { type: 'waiting_for_new_ip', new_ip: state.new_ip, attempt: state.attempt }
	}
	if (state instanceof NetworkChangeStateVariantnew_ip_reachable) {
		return { type: 'new_ip_reachable', new_ip: state.new_ip }
	}
	if (state instanceof NetworkChangeStateVariantnew_ip_timeout) {
		return { type: 'new_ip_timeout', new_ip: state.new_ip }
	}
	return { type: 'idle' }
}

// Helper to convert NetworkFormState variant to typed object
function convertNetworkFormState(state: NetworkFormState): NetworkFormStateType {
	if (state instanceof NetworkFormStateVariantidle) {
		return { type: 'idle' }
	}
	if (state instanceof NetworkFormStateVariantediting) {
		return {
			type: 'editing',
			adapter_name: state.adapter_name,
			form_data: {
				name: state.form_data.name,
				ip_address: state.form_data.ip_address,
				dhcp: state.form_data.dhcp,
				prefix_len: state.form_data.prefix_len,
				dns: [...state.form_data.dns],
				gateways: [...state.form_data.gateways],
			},
		}
	}
	if (state instanceof NetworkFormStateVariantsubmitting) {
		return {
			type: 'submitting',
			adapter_name: state.adapter_name,
			form_data: {
				name: state.form_data.name,
				ip_address: state.form_data.ip_address,
				dhcp: state.form_data.dhcp,
				prefix_len: state.form_data.prefix_len,
				dns: [...state.form_data.dns],
				gateways: [...state.form_data.gateways],
			},
		}
	}
	return { type: 'idle' }
}

// TypeScript types for the new Core state enums
export type DeviceOperationStateType =
	| { type: 'idle' }
	| { type: 'rebooting' }
	| { type: 'factory_resetting' }
	| { type: 'updating' }
	| { type: 'waiting_reconnection'; operation: string; attempt: number }
	| { type: 'reconnection_failed'; operation: string; reason: string }
	| { type: 'reconnection_successful'; operation: string }

export type NetworkChangeStateType =
	| { type: 'idle' }
	| { type: 'applying_config'; is_server_addr: boolean; ip_changed: boolean; new_ip: string; old_ip: string }
	| { type: 'waiting_for_new_ip'; new_ip: string; attempt: number }
	| { type: 'new_ip_reachable'; new_ip: string }
	| { type: 'new_ip_timeout'; new_ip: string }

export type NetworkFormStateType =
	| { type: 'idle' }
	| { type: 'editing'; adapter_name: string; form_data: NetworkFormDataType }
	| { type: 'submitting'; adapter_name: string; form_data: NetworkFormDataType }

export interface NetworkFormDataType {
	name: string
	ip_address: string
	dhcp: boolean
	prefix_len: number
	dns: string[]
	gateways: string[]
}

export interface OverlaySpinnerStateType {
	overlay: boolean
	title: string
	text: string | null
	timed_out: boolean
}

// Simple ViewModel interface for Vue reactivity (mirrors CoreViewModel but with JS types)
export interface ViewModel {
	system_info: {
    os: { name: string; version: string }
    azure_sdk_version: string
    omnect_device_service_version: string
    boot_time: string | null
  } | null
	network_status: {
		network_status: Array<{
			ipv4: {
        addrs: Array<{ addr: string; dhcp: boolean; prefix_len: number }>
        dns: string[]
        gateways: string[]
      }
      mac: string
      name: string
      online: boolean
    }>
  } | null
  online_status: { iothub: boolean } | null
	factory_reset: {
    keys: string[]
		result: {
      status: 'unknown' | 'mode_supported' | 'mode_unsupported' | 'backup_restore_error' | 'configuration_error'
      context: string | null
      error: string
      paths: string[]
    } | null
  } | null
  update_validation_status: { status: string } | null
  update_manifest: UpdateManifest | null
  timeouts: { wait_online_timeout: { nanos: number; secs: bigint } } | null
	healthcheck: {
    version_info: { version: string; git_sha: string }
    update_validation_status: { status: string }
  } | null
  is_authenticated: boolean
  requires_password_set: boolean
  is_loading: boolean
  error_message: string | null
  success_message: string | null
  is_connected: boolean
  auth_token: string | null

  // Device operation state (reboot/factory reset reconnection)
  device_operation_state: DeviceOperationStateType
  reconnection_attempt: number
  reconnection_timeout_seconds: number

  // Network change state (IP change detection and polling)
  network_change_state: NetworkChangeStateType

  // Network form state (editing without WebSocket interference)
  network_form_state: NetworkFormStateType

  // Overlay spinner state
  overlay_spinner: OverlaySpinnerStateType
}

// Singleton state
const viewModel = reactive<ViewModel>({
	system_info: null,
	network_status: null,
	online_status: null,
	factory_reset: null,
	update_validation_status: null,
	update_manifest: null,
	timeouts: null,
	healthcheck: null,
	is_authenticated: false,
	requires_password_set: false,
	is_loading: false,
	error_message: null,
	success_message: null,
	is_connected: false,
	auth_token: null,
	// Device operation state
	device_operation_state: { type: 'idle' },
	reconnection_attempt: 0,
	reconnection_timeout_seconds: 300, // 5 minutes default
	// Network change state
	network_change_state: { type: 'idle' },
	// Network form state
	network_form_state: { type: 'idle' },
	// Overlay spinner state
	overlay_spinner: { overlay: false, title: '', text: null, timed_out: false },
})

const isInitialized = ref(false)
const isSubscribed = ref(false)
const authToken = ref<string | null>(null) // New ref for auth token

// Centrifugo instance for WebSocket operations
const centrifugoInstance = useCentrifuge()
// Inject the auth token ref into Centrifugo to avoid circular dependency
centrifugoInstance.setAuthToken(authToken)

// WASM module reference (will be set when WASM is loaded)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let wasmModule: any = null

// Promise-based initialization guard to prevent both race conditions and premature event sending
let initializationPromise: Promise<void> | null = null

// ============================================================================
// Timer Management for Device Operations and Network Changes
// ============================================================================

// Timer IDs for cleanup
let reconnectionIntervalId: ReturnType<typeof setInterval> | null = null
let reconnectionTimeoutId: ReturnType<typeof setTimeout> | null = null
let newIpIntervalId: ReturnType<typeof setInterval> | null = null
let newIpTimeoutId: ReturnType<typeof setTimeout> | null = null

const RECONNECTION_POLL_INTERVAL_MS = 5000 // 5 seconds
const REBOOT_TIMEOUT_MS = 300000 // 5 minutes
const FACTORY_RESET_TIMEOUT_MS = 600000 // 10 minutes
const NEW_IP_POLL_INTERVAL_MS = 5000 // 5 seconds
const NEW_IP_TIMEOUT_MS = 90000 // 90 seconds

/**
 * Start reconnection polling for reboot/factory reset
 * Sends ReconnectionCheckTick every 5 seconds and sets a timeout
 */
function startReconnectionPolling(isFactoryReset: boolean): void {
	stopReconnectionPolling() // Clear any existing timers

	console.log(`[useCore] Starting reconnection polling (${isFactoryReset ? 'factory reset' : 'reboot'})`)

	// Start polling interval
	reconnectionIntervalId = setInterval(() => {
		if (isInitialized.value && wasmModule) {
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantReconnectionCheckTick()))
		}
	}, RECONNECTION_POLL_INTERVAL_MS)

	// Set timeout (factory reset uses longer timeout)
	const timeoutMs = isFactoryReset ? FACTORY_RESET_TIMEOUT_MS : REBOOT_TIMEOUT_MS
	reconnectionTimeoutId = setTimeout(() => {
		console.log('[useCore] Reconnection timeout reached')
		if (isInitialized.value && wasmModule) {
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantReconnectionTimeout()))
		}
		stopReconnectionPolling()
	}, timeoutMs)
}

/**
 * Stop reconnection polling
 */
function stopReconnectionPolling(): void {
	if (reconnectionIntervalId !== null) {
		clearInterval(reconnectionIntervalId)
		reconnectionIntervalId = null
	}
	if (reconnectionTimeoutId !== null) {
		clearTimeout(reconnectionTimeoutId)
		reconnectionTimeoutId = null
	}
}

/**
 * Start new IP polling after network config change
 * Sends NewIpCheckTick every 5 seconds and sets a 90-second timeout
 */
function startNewIpPolling(): void {
	stopNewIpPolling() // Clear any existing timers

	console.log('[useCore] Starting new IP polling')

	// Start polling interval
	newIpIntervalId = setInterval(() => {
		if (isInitialized.value && wasmModule) {
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantNewIpCheckTick()))
		}
	}, NEW_IP_POLL_INTERVAL_MS)

	// Set timeout
	newIpTimeoutId = setTimeout(() => {
		console.log('[useCore] New IP polling timeout reached')
		if (isInitialized.value && wasmModule) {
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantNewIpCheckTimeout()))
		}
		stopNewIpPolling()
	}, NEW_IP_TIMEOUT_MS)
}

/**
 * Stop new IP polling
 */
function stopNewIpPolling(): void {
	if (newIpIntervalId !== null) {
		clearInterval(newIpIntervalId)
		newIpIntervalId = null
	}
	if (newIpTimeoutId !== null) {
		clearTimeout(newIpTimeoutId)
		newIpTimeoutId = null
	}
}

// Watch device_operation_state for reconnection polling
watch(
	() => viewModel.device_operation_state,
	(newState, oldState) => {
		const newType = newState?.type
		const oldType = oldState?.type

		// Start polling when entering rebooting, factory_resetting, or updating state
		if (newType === 'rebooting' || newType === 'factory_resetting' || newType === 'updating') {
			startReconnectionPolling(newType === 'factory_resetting')
		}
		// Stop polling when leaving these states or entering terminal states
		else if (
			(oldType === 'rebooting' || oldType === 'factory_resetting' || oldType === 'updating' || oldType === 'waiting_reconnection') &&
			(newType === 'idle' || newType === 'reconnection_successful' || newType === 'reconnection_failed')
		) {
			stopReconnectionPolling()
		}
	},
	{ deep: true }
)

// Watch network_change_state for new IP polling and redirect
watch(
	() => viewModel.network_change_state,
	(newState, oldState) => {
		const newType = newState?.type
		const oldType = oldState?.type

		// Start polling when entering waiting_for_new_ip state
		if (newType === 'waiting_for_new_ip') {
			startNewIpPolling()
		}
		// Stop polling when leaving waiting_for_new_ip state
		else if (oldType === 'waiting_for_new_ip') {
			stopNewIpPolling()
		}

		// Navigate to new IP when it's reachable
		if (newType === 'new_ip_reachable' && 'new_ip' in newState) {
			const newIp = newState.new_ip
			console.log(`[useCore] Redirecting to new IP: ${newIp}`)
			const port = window.location.port
			const protocol = window.location.protocol
			window.location.replace(`${protocol}//${newIp}${port ? `:${port}` : ''}`)
		}
	},
	{ deep: true }
)

// ============================================================================
// Event Serialization
// ============================================================================

/**
 * Serialize an Event to bincode bytes for sending to WASM Core
 */
function serializeEvent(event: Event): Uint8Array {
	const serializer = new BincodeSerializer()
	event.serialize(serializer)
	return serializer.getBytes()
}

// ============================================================================
// HTTP Capability Implementation
// ============================================================================

/**
 * Execute an HTTP request and return the result to the Core
 *
 * This is the shell's implementation of the HTTP capability.
 * It converts the Core's HttpRequest into a fetch() call,
 * then serializes the result back for the Core to process.
 */
async function executeHttpRequest(
	requestId: number,
  httpRequest: { method: string; url: string; headers: Array<{ name: string; value: string }>; body: Uint8Array }
): Promise<void> {
	if (!wasmModule) {
    console.warn('WASM module not loaded, cannot execute HTTP request')
		return
	}

	try {
    const headers = new Headers()
		for (const header of httpRequest.headers) {
      headers.append(header.name, header.value)
		}

		const fetchOptions: RequestInit = {
			method: httpRequest.method,
			headers,
			credentials: "include",
		}

    if (httpRequest.method !== 'GET' && httpRequest.method !== 'HEAD' && httpRequest.body.length > 0) {
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			fetchOptions.body = httpRequest.body as any
		}

		// Workaround: `crux_http` in the Rust core panics on relative URLs.
		// The Rust side prefixes URLs with `http://omnect-device` to satisfy `crux_http`'s validation.
		// This side strips the prefix to send a relative URL, which `fetch` handles correctly.
		// TODO: Remove this workaround once `crux_http` supports relative URLs gracefully.
    let url = httpRequest.url
    if (url.startsWith('http://omnect-device')) {
      url = url.replace('http://omnect-device', '')
		}

    const response = await fetch(url, fetchOptions)

    // Workaround: crux_http (0.15) appears to discard the response body for 4xx/5xx errors
    // and returns a generic error. To preserve the body (which contains validation messages),
    // we map error statuses to 200 OK and pass the original status in a header.
    // The Core macro will detect this header and treat it as an error.
    let status = response.status
    const responseHeadersMap = new Headers(response.headers)
    if (status >= 400) {
      console.log(`[HTTP Effect ${requestId}] Masking status ${status} as 200 to preserve body`)
      responseHeadersMap.append('x-original-status', status.toString())
      status = 200
    }

		// Convert response headers
    const responseHeaders: Array<CoreHttpHeader> = []
		responseHeadersMap.forEach((value, name) => {
      responseHeaders.push(new CoreHttpHeader(name, value))
    })

		// Get response body as bytes
    const bodyBuffer = await response.arrayBuffer()
    const bodyBytes = new Uint8Array(bodyBuffer)
    console.log(`[HTTP Effect ${requestId}] Response body: ${bodyBytes.length} bytes`)

		// Create HttpResponse
    const httpResponse = new CoreHttpResponse(status, responseHeaders, bodyBytes)

		// Create success result
    const result = new HttpResultVariantOk(httpResponse)

    const serializer = new BincodeSerializer()
    result.serialize(serializer)
    const resultBytes = serializer.getBytes()
    const newEffectsBytes = wasmModule.handle_response(requestId, resultBytes) as Uint8Array
		if (newEffectsBytes.length > 0) {
      await processEffects(newEffectsBytes)
		}
	} catch (error) {
		// Create error result
    const errorMessage = error instanceof Error ? error.message : String(error)
    console.error(`[HTTP Effect ${requestId}] Error:`, errorMessage)
    const httpError = new HttpErrorVariantIo(errorMessage)
    const result = new HttpResultVariantErr(httpError)

    const serializer = new BincodeSerializer()
    result.serialize(serializer)
    const resultBytes = serializer.getBytes()
    const newEffectsBytes = wasmModule.handle_response(requestId, resultBytes) as Uint8Array
		if (newEffectsBytes.length > 0) {
      await processEffects(newEffectsBytes)
		}
	}
}

// ============================================================================
// Centrifugo Capability Implementation
// ============================================================================

/**
 * Convert ODS FactoryResetStatus string to typed variant
 */
function stringToFactoryResetStatus(status: string): FactoryResetStatus {
	switch (status) {
    case 'mode_supported':
      return new FactoryResetStatusVariantmode_supported()
    case 'mode_unsupported':
      return new FactoryResetStatusVariantmode_unsupported()
    case 'backup_restore_error':
      return new FactoryResetStatusVariantbackup_restore_error()
    case 'configuration_error':
      return new FactoryResetStatusVariantconfiguration_error()
		default:
      return new FactoryResetStatusVariantunknown()
	}
}

/**
 * Parse WebSocket channel data from ODS JSON and send as typed event to Core
 *
 * Architecture:
 * - Receives JSON from Centrifugo WebSocket (ODS data format)
 * - Parses JSON and constructs typed TypeScript class instances
 * - Sends as *Updated events to Core (not responses)
 * - Core processes events, updates Model, and renders
 * - Shell reads updated viewModel from Core
 *
 * This event-based approach avoids request/response conflicts with streaming data.
 */
async function parseAndSendChannelEvent(channel: string, jsonData: string): Promise<void> {
	try {
		switch (channel) {
      case 'OnlineStatusV1': {
        const json = JSON.parse(jsonData) as OdsOnlineStatus
        const data = new OnlineStatus(json.iothub)
        await sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantOnlineStatusUpdated(data)))
        break
			}
      case 'SystemInfoV1': {
        const json = JSON.parse(jsonData) as OdsSystemInfo
				const data = new SystemInfo(
          new OsInfo(json.os?.name || '', json.os?.version || ''),
          json.azure_sdk_version || '',
          json.omnect_device_service_version || '',
          json.boot_time ? String(json.boot_time) : null
        )
        await sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantSystemInfoUpdated(data)))
        break
			}
      case 'TimeoutsV1': {
        const json = JSON.parse(jsonData) as OdsTimeouts
				const data = new Timeouts(
					new Duration(
						json.wait_online_timeout?.nanos || 0,
            BigInt(json.wait_online_timeout?.secs || 0)
          )
        )
        await sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantTimeoutsUpdated(data)))
        break
			}
      case 'NetworkStatusV1': {
        const json = JSON.parse(jsonData) as OdsNetworkStatus
        console.log('NetworkStatusV1 WebSocket update received:', json)
				const networks = (json.network_status || []).map((net) => {
          console.log('Network adapter:', net.name, 'dhcp:', net.ipv4?.addrs[0]?.dhcp)
					return new DeviceNetwork(
						new InternetProtocol(
              (net.ipv4?.addrs || []).map((addr) =>
                new IpAddress(addr.addr || '', addr.dhcp || false, addr.prefix_len || 0)
							),
							net.ipv4?.dns || [],
              net.ipv4?.gateways || []
						),
            net.mac || '',
            net.name || '',
						net.online || false,
            net.file || null
          )
        })
        const data = new NetworkStatus(networks)
        await sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantNetworkStatusUpdated(data)))
        break
			}
      case 'FactoryResetV1': {
        const json = JSON.parse(jsonData) as OdsFactoryReset

				const result = json.result ? new FactoryResetResult(
          stringToFactoryResetStatus(json.result.status || 'unknown'),
					json.result.context || null,
          json.result.error || '',
          json.result.paths || []
        ) : null
        const data = new FactoryReset(json.keys || [], result)
        await sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantFactoryResetUpdated(data)))
        break
			}
      case 'UpdateValidationStatusV1': {
        const json = JSON.parse(jsonData) as OdsUpdateValidationStatus
        const data = new UpdateValidationStatus(json.status || '')
        await sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantUpdateValidationStatusUpdated(data)))
        break
			}
			default:
        console.warn(`[Centrifugo] Unknown channel: ${channel}`)
		}
	} catch (error) {
    console.error(`[Centrifugo] Error parsing ${channel}:`, error)
	}
}

/**
 * Execute Centrifugo SubscribeAll operation
 *
 * Subscribes to all Centrifugo channels and forwards messages as events to Core.
 * Uses the event-based architecture where WebSocket data is parsed and sent as
 * typed events (*Updated) rather than responses.
 *
 * Note: Only SubscribeAll is implemented - individual channel operations removed.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function executeCentrifugoOperation(operation: any): Promise<void> {
	if (operation instanceof CentrifugoOperationVariantSubscribeAll) {
    const channels = Object.values(CentrifugeSubscriptionType)
    centrifugoInstance.initializeCentrifuge()

    let subscriptionsStarted = false
		const performSubscriptions = async () => {
      if (subscriptionsStarted) return
      subscriptionsStarted = true

			for (const channel of channels) {
				await centrifugoInstance.subscribe((data: unknown) => {
          const jsonData = JSON.stringify(data)
          parseAndSendChannelEvent(channel, jsonData)
        }, channel)

				await centrifugoInstance.history((data: unknown) => {
					try {
						if (data) {
              const jsonData = JSON.stringify(data)
              parseAndSendChannelEvent(channel, jsonData)
						}
					} catch (error) {
            console.error(`[Centrifugo] Error processing history for ${channel}:`, error)
					}
        }, channel)
			}
    }

		centrifugoInstance.onConnected(() => {
      performSubscriptions()
    })
    performSubscriptions()
	} else {
    console.error(`[Centrifugo] Unsupported operation - only SubscribeAll is implemented`)
	}
}

// ============================================================================
// Effect Processing
// ============================================================================

/**
 * Process effects from the Crux Core
 *
 * Effects are the Core's way of requesting the Shell to perform side effects:
 * - Render: Fetch and update the viewModel from Core
 * - Http: Execute HTTP requests and send responses back to Core
 * - Centrifugo: Subscribe to WebSocket channels (only SubscribeAll)
 */
async function processEffects(effectsBytes: Uint8Array): Promise<void> {
	if (!wasmModule) {
    console.warn('WASM module not loaded, cannot process effects')
    return
	}

	// Deserialize effects from bincode (array of Request objects)
  const deserializer = new BincodeDeserializer(effectsBytes)
  const numRequests = deserializer.deserializeLen()

	for (let i = 0; i < numRequests; i++) {
    const request = CruxRequest.deserialize(deserializer)
    const effect = request.effect

		if (effect instanceof EffectVariantRender) {
			// Render effect: Update the view model from core
      updateViewModelFromCore()
		} else if (effect instanceof EffectVariantHttp) {
			// HTTP effect: Execute HTTP request and send response back to core
      const httpRequest = effect.value
      console.log(`HTTP ${httpRequest.method} ${httpRequest.url}`)

			// Execute the request asynchronously (don't await to allow parallel processing)
			executeHttpRequest(request.id, {
				method: httpRequest.method,
				url: httpRequest.url,
        headers: httpRequest.headers.map(h => ({ name: h.name, value: h.value })),
				body: httpRequest.body,
			}).catch((error) => {
        console.error('Failed to execute HTTP request:', error)
      })
		} else if (effect instanceof EffectVariantCentrifugo) {
			// Centrifugo effect: Handle WebSocket subscription
      const centrifugoOperation = effect.value
      console.log(`Centrifugo operation:`, centrifugoOperation)

			// Execute the operation asynchronously
			executeCentrifugoOperation(centrifugoOperation).catch((error) => {
        console.error('Failed to execute Centrifugo operation:', error)
      })
		} else {
      console.warn('Unknown effect type:', effect)
		}
	}
}

// ============================================================================
// ViewModel Synchronization
// ============================================================================

/**
 * Fetch and deserialize the view model from Crux Core
 *
 * Reads the serialized viewModel bytes from WASM, deserializes using bincode,
 * and updates the reactive Vue viewModel object.
 */
function updateViewModelFromCore(): void {
	if (!wasmModule) {
		return
	}

	try {
		// Capture authentication state before update to detect transitions
		const wasAuthenticated = viewModel.is_authenticated

		// Get serialized view model from WASM
    const viewModelBytes = wasmModule.view() as Uint8Array

		// Deserialize it using the generated ViewModel class
    const deserializer = new BincodeDeserializer(viewModelBytes)
    const coreViewModel = GeneratedViewModel.deserialize(deserializer)

		// Update the reactive view model with deserialized data
		// system_info
		if (coreViewModel.system_info) {
			viewModel.system_info = {
				os: {
					name: coreViewModel.system_info.os.name,
					version: coreViewModel.system_info.os.version,
				},
				azure_sdk_version: coreViewModel.system_info.azure_sdk_version,
        omnect_device_service_version: coreViewModel.system_info.omnect_device_service_version,
				boot_time: coreViewModel.system_info.boot_time || null,
      }
		} else {
      viewModel.system_info = null
		}

		// network_status
		if (coreViewModel.network_status) {
			viewModel.network_status = {
        network_status: coreViewModel.network_status.network_status.map((net) => ({
						ipv4: {
							addrs: net.ipv4.addrs.map((addr) => ({
								addr: addr.addr,
								dhcp: addr.dhcp,
								prefix_len: addr.prefix_len,
							})),
							dns: net.ipv4.dns,
							gateways: net.ipv4.gateways,
						},
						mac: net.mac,
						name: net.name,
						online: net.online,
        })),
      }
		} else {
      viewModel.network_status = null
		}

		// online_status
		viewModel.online_status = coreViewModel.online_status
			? { iothub: coreViewModel.online_status.iothub }
      : null

		// factory_reset - convert status variant to string literal
		// Note: Skip if deserialization fails (can happen with bincode format mismatches)
		try {
			viewModel.factory_reset = coreViewModel.factory_reset
				? {
						keys: coreViewModel.factory_reset.keys,
            result: coreViewModel.factory_reset.result ? {
              status: factoryResetStatusToString(coreViewModel.factory_reset.result.status),
									context: coreViewModel.factory_reset.result.context || null,
									error: coreViewModel.factory_reset.result.error,
									paths: coreViewModel.factory_reset.result.paths,
            } : null,
					}
        : null
		} catch (error) {
      console.warn('[updateViewModelFromCore] Failed to deserialize factory_reset, keeping existing value:', error)
		}

		// update_validation_status
		viewModel.update_validation_status = coreViewModel.update_validation_status
			? { status: coreViewModel.update_validation_status.status }
      : null

		// update_manifest
		viewModel.update_manifest = coreViewModel.update_manifest ?? null

		// timeouts
		viewModel.timeouts = coreViewModel.timeouts
			? {
					wait_online_timeout: {
						nanos: coreViewModel.timeouts.wait_online_timeout.nanos,
						secs: coreViewModel.timeouts.wait_online_timeout.secs,
					},
				}
      : null

		// healthcheck
		viewModel.healthcheck = coreViewModel.healthcheck
			? {
					version_info: {
						version: coreViewModel.healthcheck.version_info.version,
						git_sha: coreViewModel.healthcheck.version_info.git_sha,
					},
					update_validation_status: {
						status: coreViewModel.healthcheck.update_validation_status.status,
					},
				}
      : null

		// Boolean and string fields
		viewModel.is_authenticated = coreViewModel.is_authenticated
		viewModel.requires_password_set = coreViewModel.requires_password_set
		viewModel.is_loading = coreViewModel.is_loading
		viewModel.error_message = coreViewModel.error_message || null
		viewModel.success_message = coreViewModel.success_message || null
		viewModel.is_connected = coreViewModel.is_connected
		viewModel.auth_token = coreViewModel.auth_token || null

		// Sync the ref with the view model
		authToken.value = viewModel.auth_token

		// Device operation state - convert bincode variant to typed object
		viewModel.device_operation_state = convertDeviceOperationState(coreViewModel.device_operation_state)
		viewModel.reconnection_attempt = coreViewModel.reconnection_attempt
		viewModel.reconnection_timeout_seconds = coreViewModel.reconnection_timeout_seconds

		// Network change state
		viewModel.network_change_state = convertNetworkChangeState(coreViewModel.network_change_state)

		// Network form state
		viewModel.network_form_state = convertNetworkFormState(coreViewModel.network_form_state)

		// Overlay spinner state
		viewModel.overlay_spinner = {
			overlay: coreViewModel.overlay_spinner.overlay,
			title: coreViewModel.overlay_spinner.title,
			text: coreViewModel.overlay_spinner.text || null,
			timed_out: coreViewModel.overlay_spinner.timed_out,
		}

		// Auto-subscribe logic based on authentication state transition
		if (viewModel.is_authenticated && !wasAuthenticated) {
			console.log('[useCore] User authenticated, triggering subscription')
			if (authToken.value && !isSubscribed.value) {
				isSubscribed.value = true
				sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantSubscribeToChannels()))
			}
		}

		// Reset subscription state on logout
		if (!viewModel.is_authenticated && wasAuthenticated) {
			console.log('[useCore] User logged out, resetting subscription state and disconnecting Centrifugo')
			isSubscribed.value = false
			// Disconnect Centrifugo to ensure old tokens are not reused
			centrifugoInstance.disconnect()
		}
	} catch (error) {
    console.error('Failed to update view model from core:', error)
		// Don't throw - keep the viewModel as-is from events
		// This allows the app to continue working even if Core's viewModel has deserialization issues
	}
}

/**
 * Send an event to the Crux Core
 *
 * This serializes the event, sends it to the WASM core, and processes
 * any resulting effects.
 */
async function sendEventToCore(event: Event): Promise<void> {
	if (!isInitialized.value || !wasmModule) {
    console.warn('Core not initialized, cannot send event')
    return
	}

	try {
		// Serialize the event using bincode
    const eventBytes = serializeEvent(event)

		// Call process_event() on the WASM module
    const effectsBytes = wasmModule.process_event(eventBytes) as Uint8Array

		// Process the resulting effects
    await processEffects(effectsBytes)
	} catch (error) {
    console.error('Failed to send event to core:', error)
	}
}

/**
 * Initialize the Crux Core
 *
 * This loads the WASM module and sets up the core state.
 * Uses a promise-based guard to prevent both race conditions and premature event sending.
 */
async function initializeCore(): Promise<void> {
	// If initialization is already in progress or complete, wait for/return that promise
	if (initializationPromise) {
    return initializationPromise
	}

	// Create and store the initialization promise
	initializationPromise = (async () => {
    console.log('Initializing Crux Core...')

		try {
			// Dynamically import the WASM module
			// This will be available after running:
			// cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
      const wasm = await import('../core/pkg/omnect_ui_core')
      await wasm.default()
      wasmModule = wasm

      console.log('Crux Core WASM module loaded successfully')

			// Only set initialized flag after WASM is fully loaded
      isInitialized.value = true

			// Send initial event
      await sendEventToCore(new EventVariantinitialize())
		} catch (error) {
      console.error('Failed to load Crux Core WASM module:', error)
      console.log('Running in fallback mode without WASM')
			// Set initialized flag even on error to prevent retry loops
      isInitialized.value = true
		}
  })()

  return initializationPromise
}

// ============================================================================
// Public API
// ============================================================================

/**
 * Vue composable for Crux Core integration
 *
 * Provides the main interface for Vue components to interact with the Rust
 * Crux Core compiled to WASM.
 *
 * @example
 * ```typescript
 * const { viewModel, sendEvent, initialize } = useCore()
 *
 * onMounted(async () => {
 *   await initialize()
 * })
 *
 * // Access reactive view model
 * const isOnline = computed(() => viewModel.online_status?.iothub ?? false)
 *
 * // Send events using convenience methods
 * login('password')
 * reboot()
 * ```
 */
export function useCore() {
	return {
		// Provide readonly access to the view model
		viewModel: readonly(viewModel) as DeepReadonly<ViewModel>,

		// Event sending (using Event type from shared_types)
		sendEvent: sendEventToCore,
		// Provide authToken for direct use
		authToken: readonly(authToken),

		// Initialization
		initialize: initializeCore,
		isInitialized: readonly(isInitialized),

		// Convenience methods for common events
		login: (password: string) =>
			sendEventToCore(new EventVariantauth(new AuthEventVariantLogin(password))),
		logout: () => sendEventToCore(new EventVariantauth(new AuthEventVariantLogout())),
		setPassword: (password: string) => sendEventToCore(new EventVariantauth(new AuthEventVariantSetPassword(password))),
		updatePassword: (currentPassword: string, password: string) =>
			sendEventToCore(new EventVariantauth(new AuthEventVariantUpdatePassword(currentPassword, password))),
		checkRequiresPasswordSet: () => sendEventToCore(new EventVariantauth(new AuthEventVariantCheckRequiresPasswordSet())),
		reboot: () => sendEventToCore(new EventVariantdevice(new DeviceEventVariantReboot())),
		factoryReset: (mode: string, preserve: string[]) =>
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantFactoryResetRequest(mode, preserve))),
		reloadNetwork: () => sendEventToCore(new EventVariantdevice(new DeviceEventVariantReloadNetwork())),
		setNetworkConfig: (config: string) =>
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantSetNetworkConfig(config))),
		loadUpdate: (filePath: string) => sendEventToCore(new EventVariantdevice(new DeviceEventVariantLoadUpdate(filePath))),
		runUpdate: (validateIothub: boolean) =>
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantRunUpdate(validateIothub))),
		subscribeToChannels: () => {
			if (isSubscribed.value) {
				return
			}
			if (!authToken.value) {
				console.warn('[useCore] Skipping subscription: no auth token')
				return
			}
			isSubscribed.value = true
			sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantSubscribeToChannels()))
		},
		unsubscribeFromChannels: () => {
			isSubscribed.value = false
			sendEventToCore(new EventVariantweb_socket(new WebSocketEventVariantUnsubscribeFromChannels()))
		},
		clearError: () => sendEventToCore(new EventVariantui(new UiEventVariantClearError())),
		clearSuccess: () => sendEventToCore(new EventVariantui(new UiEventVariantClearSuccess())),

		// Network form state management
		networkFormStartEdit: (adapterName: string) =>
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantNetworkFormStartEdit(adapterName))),
		networkFormUpdate: (formDataJson: string) =>
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantNetworkFormUpdate(formDataJson))),
		networkFormReset: (adapterName: string) =>
			sendEventToCore(new EventVariantdevice(new DeviceEventVariantNetworkFormReset(adapterName))),
	}
}
