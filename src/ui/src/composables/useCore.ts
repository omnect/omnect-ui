/**
 * Vue composable for integrating with Crux Core
 *
 * This composable provides the bridge between the Vue UI shell and the
 * Crux Core (Rust compiled to WASM). It handles:
 * - Sending events to the core
 * - Processing effects from the core
 * - Providing reactive access to the view model
 *
 * The generated types from shared_types provide serialization/deserialization
 * for bincode FFI communication with the WASM module.
 *
 * Build the WASM module with:
 *   cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
 *
 * Generate TypeScript types with:
 *   export PATH="$HOME/.local/share/pnpm:$PATH" && cargo build -p shared_types
 */

import { ref, reactive, readonly, type DeepReadonly } from 'vue'

// Re-export generated types from shared_types for use in Vue components
// These types are generated by TypeGen from the Crux Core Rust types
export type {
  SystemInfo,
  NetworkStatus,
  OnlineStatus,
  FactoryReset,
  UpdateValidationStatus,
  Timeouts,
  HealthcheckInfo,
  Event,
  Effect,
  ViewModel as CoreViewModel,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import event constructors for sending events to the core
import {
  EventVariantInitialize,
  EventVariantLogin,
  EventVariantLogout,
  EventVariantSetPassword,
  EventVariantUpdatePassword,
  EventVariantCheckRequiresPasswordSet,
  EventVariantReboot,
  EventVariantFactoryResetRequest,
  EventVariantReloadNetwork,
  EventVariantSetNetworkConfig,
  EventVariantLoadUpdate,
  EventVariantRunUpdate,
  EventVariantSubscribeToChannels,
  EventVariantUnsubscribeFromChannels,
  EventVariantClearError,
  EventVariantClearSuccess,
  type Event,
  ViewModel as GeneratedViewModel,
  Request as CruxRequest,
  Effect as EffectClass,
  EffectVariantRender,
  EffectVariantHttp,
  EffectVariantCentrifugo,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import serialization utilities
import { BincodeSerializer } from '../../../shared_types/generated/typescript/bincode/mod'
import { BincodeDeserializer } from '../../../shared_types/generated/typescript/bincode/mod'

// Simple ViewModel interface for Vue reactivity (mirrors CoreViewModel but with JS types)
export interface ViewModel {
  system_info: {
    os: { name: string; version: string }
    azure_sdk_version: string
    omnect_device_service_version: string
    boot_time: string | null
  } | null
  network_status: {
    network_status: Array<{
      ipv4: {
        addrs: Array<{ addr: string; dhcp: boolean; prefix_len: number }>
        dns: string[]
        gateways: string[]
      }
      mac: string
      name: string
      online: boolean
    }>
  } | null
  online_status: { iothub: boolean } | null
  factory_reset: {
    keys: string[]
    result: {
      status: string
      context: string | null
      error: string
      paths: string[]
    }
  } | null
  update_validation_status: { status: string } | null
  timeouts: { wait_online_timeout: { nanos: number; secs: bigint } } | null
  healthcheck: {
    version_info: { version: string; git_sha: string }
    update_validation_status: { status: string }
  } | null
  is_authenticated: boolean
  requires_password_set: boolean
  is_loading: boolean
  error_message: string | null
  success_message: string | null
  is_connected: boolean
}

// Singleton state
const viewModel = reactive<ViewModel>({
  system_info: null,
  network_status: null,
  online_status: null,
  factory_reset: null,
  update_validation_status: null,
  timeouts: null,
  healthcheck: null,
  is_authenticated: false,
  requires_password_set: false,
  is_loading: false,
  error_message: null,
  success_message: null,
  is_connected: false,
})

const isInitialized = ref(false)

// WASM module reference (will be set when WASM is loaded)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let wasmModule: any = null

/**
 * Serialize an Event to bincode bytes
 */
function serializeEvent(event: Event): Uint8Array {
  const serializer = new BincodeSerializer()
  event.serialize(serializer)
  return serializer.getBytes()
}

/**
 * Process effects from the Crux Core
 *
 * When the core returns effects, this function handles them:
 * - Render: Update the view model by fetching it from the core
 * - Http: Make HTTP requests and send responses back to core
 * - Centrifugo: Handle WebSocket subscriptions
 */
async function processEffects(effectsBytes: Uint8Array): Promise<void> {
  if (!wasmModule) {
    console.warn('WASM module not loaded, cannot process effects')
    return
  }

  // Deserialize effects from bincode (array of Request objects)
  const deserializer = new BincodeDeserializer(effectsBytes)
  const numRequests = deserializer.deserializeLen()

  for (let i = 0; i < numRequests; i++) {
    const request = CruxRequest.deserialize(deserializer)
    const effect = request.effect

    if (effect instanceof EffectVariantRender) {
      // Render effect: Update the view model from core
      updateViewModelFromCore()
    } else if (effect instanceof EffectVariantHttp) {
      // HTTP effect: Execute HTTP request and send response back to core
      console.log('HTTP effect received - not yet implemented', effect.value)
      // TODO: Execute HTTP request and send response back using handle_response
    } else if (effect instanceof EffectVariantCentrifugo) {
      // Centrifugo effect: Handle WebSocket subscription
      console.log('Centrifugo effect received - not yet implemented', effect.value)
      // TODO: Handle WebSocket subscription
    } else {
      console.warn('Unknown effect type:', effect)
    }
  }
}

/**
 * Update the reactive view model from the Crux Core
 */
function updateViewModelFromCore(): void {
  if (!wasmModule) {
    return
  }

  try {
    // Get serialized view model from WASM
    const viewModelBytes = wasmModule.view() as Uint8Array

    // Deserialize it using the generated ViewModel class
    const deserializer = new BincodeDeserializer(viewModelBytes)
    const coreViewModel = GeneratedViewModel.deserialize(deserializer)

    // Update the reactive view model with deserialized data
    // system_info
    if (coreViewModel.system_info) {
      viewModel.system_info = {
        os: {
          name: coreViewModel.system_info.os.name,
          version: coreViewModel.system_info.os.version,
        },
        azure_sdk_version: coreViewModel.system_info.azure_sdk_version,
        omnect_device_service_version: coreViewModel.system_info.omnect_device_service_version,
        boot_time: coreViewModel.system_info.boot_time || null,
      }
    } else {
      viewModel.system_info = null
    }

    // network_status
    if (coreViewModel.network_status) {
      viewModel.network_status = {
        network_status: coreViewModel.network_status.network_status.map((net) => ({
          ipv4: {
            addrs: net.ipv4.addrs.map((addr) => ({
              addr: addr.addr,
              dhcp: addr.dhcp,
              prefix_len: addr.prefix_len,
            })),
            dns: net.ipv4.dns,
            gateways: net.ipv4.gateways,
          },
          mac: net.mac,
          name: net.name,
          online: net.online,
        })),
      }
    } else {
      viewModel.network_status = null
    }

    // online_status
    viewModel.online_status = coreViewModel.online_status
      ? { iothub: coreViewModel.online_status.iothub }
      : null

    // factory_reset - complex nested type, simplified for now
    viewModel.factory_reset = coreViewModel.factory_reset
      ? {
          keys: coreViewModel.factory_reset.keys,
          result: {
            status: coreViewModel.factory_reset.result.status.constructor.name,
            context: coreViewModel.factory_reset.result.context || null,
            error: coreViewModel.factory_reset.result.error,
            paths: coreViewModel.factory_reset.result.paths,
          },
        }
      : null

    // update_validation_status
    viewModel.update_validation_status = coreViewModel.update_validation_status
      ? { status: coreViewModel.update_validation_status.status }
      : null

    // timeouts
    viewModel.timeouts = coreViewModel.timeouts
      ? {
          wait_online_timeout: {
            nanos: coreViewModel.timeouts.wait_online_timeout.nanos,
            secs: coreViewModel.timeouts.wait_online_timeout.secs,
          },
        }
      : null

    // healthcheck
    viewModel.healthcheck = coreViewModel.healthcheck
      ? {
          version_info: {
            version: coreViewModel.healthcheck.version_info.version,
            git_sha: coreViewModel.healthcheck.version_info.git_sha,
          },
          update_validation_status: {
            status: coreViewModel.healthcheck.update_validation_status.status,
          },
        }
      : null

    // Boolean and string fields
    viewModel.is_authenticated = coreViewModel.is_authenticated
    viewModel.requires_password_set = coreViewModel.requires_password_set
    viewModel.is_loading = coreViewModel.is_loading
    viewModel.error_message = coreViewModel.error_message || null
    viewModel.success_message = coreViewModel.success_message || null
    viewModel.is_connected = coreViewModel.is_connected
  } catch (error) {
    console.error('Failed to update view model from core:', error)
  }
}

/**
 * Send an event to the Crux Core
 *
 * This serializes the event, sends it to the WASM core, and processes
 * any resulting effects.
 */
async function sendEventToCore(event: Event): Promise<void> {
  if (!isInitialized.value || !wasmModule) {
    console.warn('Core not initialized, cannot send event')
    return
  }

  try {
    // Serialize the event using bincode
    const eventBytes = serializeEvent(event)

    // Call process_event() on the WASM module
    const effectsBytes = wasmModule.process_event(eventBytes) as Uint8Array

    // Process the resulting effects
    await processEffects(effectsBytes)
  } catch (error) {
    console.error('Failed to send event to core:', error)
  }
}

/**
 * Initialize the Crux Core
 *
 * This loads the WASM module and sets up the core state.
 */
async function initializeCore(): Promise<void> {
  if (isInitialized.value) {
    return
  }

  console.log('Initializing Crux Core...')

  try {
    // Dynamically import the WASM module
    // This will be available after running:
    // cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
    const wasm = await import('../core/pkg/omnect_ui_core')
    await wasm.default()
    wasmModule = wasm

    isInitialized.value = true
    console.log('Crux Core WASM module loaded successfully')

    // Send initial event
    await sendEventToCore(new EventVariantInitialize())
  } catch (error) {
    console.error('Failed to load Crux Core WASM module:', error)
    console.log('Running in fallback mode without WASM')
    isInitialized.value = true
  }
}

/**
 * Vue composable for Crux Core integration
 *
 * Usage:
 * ```typescript
 * const { viewModel, sendEvent, initialize } = useCore()
 *
 * onMounted(() => {
 *   initialize()
 * })
 *
 * // Send events using event constructors
 * sendEvent(new EventVariantLogin('user', 'pass'))
 *
 * // Or use convenience methods
 * login('user', 'pass')
 *
 * // Access view model
 * const isLoading = computed(() => viewModel.is_loading)
 * ```
 */
export function useCore() {
  return {
    // Provide readonly access to the view model
    viewModel: readonly(viewModel) as DeepReadonly<ViewModel>,

    // Event sending (using Event type from shared_types)
    sendEvent: sendEventToCore,

    // Initialization
    initialize: initializeCore,
    isInitialized: readonly(isInitialized),

    // Convenience methods for common events
    login: (username: string, password: string) =>
      sendEventToCore(new EventVariantLogin(username, password)),
    logout: () => sendEventToCore(new EventVariantLogout()),
    setPassword: (password: string) => sendEventToCore(new EventVariantSetPassword(password)),
    updatePassword: (current: string, newPassword: string) =>
      sendEventToCore(new EventVariantUpdatePassword(current, newPassword)),
    checkRequiresPasswordSet: () => sendEventToCore(new EventVariantCheckRequiresPasswordSet()),
    reboot: () => sendEventToCore(new EventVariantReboot()),
    factoryReset: (mode: string, preserve: string[]) =>
      sendEventToCore(new EventVariantFactoryResetRequest(mode, preserve)),
    reloadNetwork: () => sendEventToCore(new EventVariantReloadNetwork()),
    setNetworkConfig: (config: string) =>
      sendEventToCore(new EventVariantSetNetworkConfig(config)),
    loadUpdate: (filePath: string) => sendEventToCore(new EventVariantLoadUpdate(filePath)),
    runUpdate: (validateIothub: boolean) =>
      sendEventToCore(new EventVariantRunUpdate(validateIothub)),
    subscribeToChannels: () => sendEventToCore(new EventVariantSubscribeToChannels()),
    unsubscribeFromChannels: () => sendEventToCore(new EventVariantUnsubscribeFromChannels()),
    clearError: () => sendEventToCore(new EventVariantClearError()),
    clearSuccess: () => sendEventToCore(new EventVariantClearSuccess()),
  }
}
